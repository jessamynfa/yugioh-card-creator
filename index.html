<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Yu-Gi-Oh! Card Creator</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        const { useState, useEffect } = React;

        const YuGiOhCardCreator = () => {
          const [cardData, setCardData] = useState({
            name: 'Herobrine',
            type: 'minecraft',
            attribute: 'DARK',
            level: 10,
            monsterType: 'Creepypasta/Effect',
            minecraftType: 'Creepypasta',
            attack: 2500,
            defense: 2000,
            description: 'A mysterious entity that haunts Minecraft worlds. When summoned: All opponent monsters lose 500 ATK. If this card destroys a monster by battle, place 1 "Cursed Block" token on your field.',
            spellType: 'Normal',
            trapType: 'Normal'
          });

          const [cardImage, setCardImage] = useState(null);

          // Auto-load Herobrine image when card name is "Herobrine"
          useEffect(() => {
            if (cardData.name === 'Herobrine') {
              // Enhanced SVG with moderately glowing eyes
              const svgDataUri = 'data:image/svg+xml,' + encodeURIComponent(`
                <svg width="200" height="200" xmlns="http://www.w3.org/2000/svg">
                  <defs>
                    <radialGradient id="eyeGlow" cx="50%" cy="50%" r="80%">
                      <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.9" />
                      <stop offset="30%" style="stop-color:#e6e6e6;stop-opacity:0.8" />
                      <stop offset="60%" style="stop-color:#cccccc;stop-opacity:0.6" />
                      <stop offset="100%" style="stop-color:#999999;stop-opacity:0.4" />
                    </radialGradient>
                    <radialGradient id="outerGlow" cx="50%" cy="50%" r="100%">
                      <stop offset="0%" style="stop-color:#ffffff;stop-opacity:0.4" />
                      <stop offset="40%" style="stop-color:#cccccc;stop-opacity:0.2" />
                      <stop offset="80%" style="stop-color:#999999;stop-opacity:0.1" />
                      <stop offset="100%" style="stop-color:#888888;stop-opacity:0" />
                    </radialGradient>
                    <filter id="glow">
                      <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                      <feMerge> 
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                      </feMerge>
                    </filter>
                  </defs>
                  <rect width="200" height="200" fill="#1a1a1a"/>
                  <rect x="50" y="50" width="100" height="100" fill="#4a4a4a"/>
                  <rect x="58" y="67" width="31" height="22" fill="url(#outerGlow)"/>
                  <rect x="111" y="67" width="31" height="22" fill="url(#outerGlow)"/>
                  <rect x="66" y="72" width="25" height="16" fill="url(#eyeGlow)" filter="url(#glow)"/>
                  <rect x="109" y="72" width="25" height="16" fill="url(#eyeGlow)" filter="url(#glow)"/>
                  <rect x="73" y="76" width="11" height="8" fill="#ffffff" opacity="0.8"/>
                  <rect x="116" y="76" width="11" height="8" fill="#ffffff" opacity="0.8"/>
                </svg>
              `);
              setCardImage(svgDataUri);
            } else if (cardData.name !== 'Herobrine' && cardImage && cardImage.includes('svg')) {
              setCardImage(null);
            }
          }, [cardData.name]);

          // Smart emoji/image detection based on card name keywords
          const getSmartCardEmoji = () => {
            const name = cardData.name.toLowerCase();
            
            // Specific card name combinations (check these first for exact matches)
            if (name.includes('blue') && name.includes('eyes')) return 'üîµ';
            if (name.includes('beast')) return 'üê∫';
            
            // Character/People keywords
            if (name.includes('girl') || name.includes('woman') || name.includes('lady') || name.includes('princess')) return 'üëß';
            if (name.includes('boy') || name.includes('man') || name.includes('warrior') || name.includes('knight')) return 'üë¶';
            if (name.includes('magician') || name.includes('wizard') || name.includes('witch') || name.includes('mage')) return 'üßô';
            if (name.includes('hero') || name.includes('champion')) return 'ü¶∏';
            if (name.includes('ninja') || name.includes('assassin')) return 'ü•∑';
            if (name.includes('pirate')) return 'üè¥‚Äç‚ò†Ô∏è';
            if (name.includes('angel')) return 'üëº';
            if (name.includes('demon') || name.includes('devil')) return 'üëπ';
            if (name.includes('ghost') || name.includes('spirit')) return 'üëª';
            if (name.includes('zombie')) return 'üßü';
            
            // Creatures/Monsters
            if (name.includes('dragon')) return 'üêâ';
            if (name.includes('phoenix') || name.includes('bird')) return 'ü¶Ö';
            if (name.includes('wolf') || name.includes('dog')) return 'üê∫';
            if (name.includes('cat') || name.includes('lion')) return 'ü¶Å';
            if (name.includes('tiger')) return 'üêÖ';
            if (name.includes('bear')) return 'üêª';
            if (name.includes('snake') || name.includes('serpent')) return 'üêç';
            if (name.includes('spider')) return 'üï∑Ô∏è';
            if (name.includes('scorpion')) return 'ü¶Ç';
            if (name.includes('shark')) return 'ü¶à';
            if (name.includes('whale')) return 'üêã';
            if (name.includes('octopus')) return 'üêô';
            if (name.includes('eagle')) return 'ü¶Ö';
            if (name.includes('bat')) return 'ü¶á';
            if (name.includes('skull')) return 'üíÄ';
            if (name.includes('monster')) return 'üëæ';
            
            // Minecraft specific
            if (name.includes('creeper')) return 'üíö';
            if (name.includes('enderman')) return '‚ö´';
            if (name.includes('zombie')) return 'üßü';
            if (name.includes('skeleton')) return 'üíÄ';
            if (name.includes('spider')) return 'üï∑Ô∏è';
            if (name.includes('slime')) return 'üü¢';
            if (name.includes('blaze')) return 'üî•';
            if (name.includes('herobrine')) return 'üëÅÔ∏è';
            if (name.includes('steve')) return 'üë®‚Äçüîß';
            if (name.includes('alex')) return 'üë©‚Äçüîß';
            if (name.includes('villager')) return 'üë®‚Äçüåæ';
            if (name.includes('golem')) return 'üóø';
            if (name.includes('wither')) return 'üíÄ';
            if (name.includes('ender')) return 'üåå';
            
            // Objects/Weapons
            if (name.includes('sword') || name.includes('blade')) return '‚öîÔ∏è';
            if (name.includes('bow') || name.includes('arrow')) return 'üèπ';
            if (name.includes('shield')) return 'üõ°Ô∏è';
            if (name.includes('staff') || name.includes('wand')) return 'ü™Ñ';
            if (name.includes('hammer')) return 'üî®';
            if (name.includes('axe')) return 'ü™ì';
            if (name.includes('spear')) return 'üó°Ô∏è';
            if (name.includes('crown')) return 'üëë';
            if (name.includes('gem') || name.includes('crystal') || name.includes('diamond')) return 'üíé';
            if (name.includes('ring')) return 'üíç';
            if (name.includes('orb') || name.includes('sphere')) return 'üîÆ';
            if (name.includes('book') || name.includes('tome')) return 'üìö';
            if (name.includes('scroll')) return 'üìú';
            if (name.includes('potion') || name.includes('bottle')) return 'üß™';
            if (name.includes('bomb') || name.includes('explosive')) return 'üí£';
            if (name.includes('coin') || name.includes('gold')) return 'ü™ô';
            if (name.includes('key')) return 'üóùÔ∏è';
            if (name.includes('chest') || name.includes('treasure')) return 'üì¶';
            
            // Elements/Nature
            if (name.includes('fire') || name.includes('flame') || name.includes('burn')) return 'üî•';
            if (name.includes('ice') || name.includes('frost') || name.includes('snow')) return '‚ùÑÔ∏è';
            if (name.includes('water') || name.includes('ocean') || name.includes('sea')) return 'üåä';
            if (name.includes('lightning') || name.includes('thunder') || name.includes('electric')) return '‚ö°';
            if (name.includes('earth') || name.includes('rock') || name.includes('stone')) return 'ü™®';
            if (name.includes('wind') || name.includes('air') || name.includes('storm')) return 'üå™Ô∏è';
            if (name.includes('plant') || name.includes('tree') || name.includes('forest')) return 'üå≥';
            if (name.includes('flower') || name.includes('rose')) return 'üåπ';
            if (name.includes('star') || name.includes('celestial')) return '‚≠ê';
            if (name.includes('moon') || name.includes('lunar')) return 'üåô';
            if (name.includes('sun') || name.includes('solar')) return '‚òÄÔ∏è';
            if (name.includes('shadow') || name.includes('dark')) return 'üåë';
            if (name.includes('light') || name.includes('bright')) return 'üåü';
            
            // Vehicles/Machines
            if (name.includes('machine') || name.includes('robot') || name.includes('cyber')) return 'ü§ñ';
            if (name.includes('car') || name.includes('vehicle')) return 'üöó';
            if (name.includes('ship') || name.includes('boat')) return 'üö¢';
            if (name.includes('plane') || name.includes('aircraft')) return '‚úàÔ∏è';
            if (name.includes('rocket')) return 'üöÄ';
            if (name.includes('train')) return 'üöÇ';
            
            // Buildings/Places
            if (name.includes('castle') || name.includes('fortress')) return 'üè∞';
            if (name.includes('tower')) return 'üóº';
            if (name.includes('temple') || name.includes('shrine')) return '‚õ©Ô∏è';
            if (name.includes('house') || name.includes('home')) return 'üè†';
            if (name.includes('city')) return 'üèôÔ∏è';
            if (name.includes('mountain')) return '‚õ∞Ô∏è';
            if (name.includes('volcano')) return 'üåã';
            if (name.includes('cave')) return 'üï≥Ô∏è';
            
            // Food (for fun cards)
            if (name.includes('cake') || name.includes('sweet')) return 'üç∞';
            if (name.includes('pizza')) return 'üçï';
            if (name.includes('burger')) return 'üçî';
            if (name.includes('apple')) return 'üçé';
            if (name.includes('banana')) return 'üçå';
            
            // Fallback to type-based emoji if no keyword matches
            return getCardEmoji();
          };

          // Keep the original function for type-based emojis
          const getCardEmoji = () => {
            if (cardData.type === 'monster') {
              const monsterAttributeEmojis = {
                'LIGHT': 'üåü',
                'DARK': 'üåë', 
                'WATER': 'üåä',
                'FIRE': 'üî•',
                'EARTH': '‚õ∞Ô∏è',
                'WIND': 'üå™Ô∏è',
                'DIVINE': 'üëë'
              };
              return monsterAttributeEmojis[cardData.attribute] || 'üêâ';
            }
            
            if (cardData.type === 'minecraft') {
              const minecraftAttributeEmojis = {
                'LIGHT': '‚òÄÔ∏è',
                'DARK': 'üåö',
                'WATER': 'üåÄ',
                'FIRE': 'üî•',
                'EARTH': 'üü´',
                'WIND': 'üí®',
                'DIVINE': '‚≠ê'
              };
              return minecraftAttributeEmojis[cardData.attribute] || 'üßä';
            }
            
            if (cardData.type === 'spell') {
              const spellTypeEmojis = {
                'Normal': 'ü™Ñ',
                'Quick-Play': '‚ö°',
                'Continuous': 'üîÑ',
                'Equip': '‚öîÔ∏è',
                'Field': 'üó∫Ô∏è',
                'Ritual': 'üïØÔ∏è'
              };
              return spellTypeEmojis[cardData.spellType] || 'ü™Ñ';
            }
            
            if (cardData.type === 'trap') {
              const trapTypeEmojis = {
                'Normal': 'ü™§',
                'Continuous': '‚è∞',
                'Counter': 'üõ°Ô∏è'
              };
              return trapTypeEmojis[cardData.trapType] || 'ü™§';
            }
            
            return '‚ùì';
          };

          // Dynamic antique card colors based on type and attribute
          const getCardColors = () => {
            if (cardData.type === 'monster') {
              const monsterColors = {
                'LIGHT': 'bg-gradient-to-br from-amber-50 via-yellow-100 to-orange-200',
                'DARK': 'bg-gradient-to-br from-purple-900 via-gray-800 to-indigo-900',
                'WATER': 'bg-gradient-to-br from-cyan-100 via-blue-200 to-teal-300',
                'FIRE': 'bg-gradient-to-br from-red-200 via-orange-300 to-yellow-400',
                'EARTH': 'bg-gradient-to-br from-amber-200 via-yellow-300 to-orange-400',
                'WIND': 'bg-gradient-to-br from-emerald-100 via-teal-200 to-cyan-300',
                'DIVINE': 'bg-gradient-to-br from-yellow-200 via-amber-300 to-orange-400'
              };
              return monsterColors[cardData.attribute] || monsterColors['LIGHT'];
            }
            
            if (cardData.type === 'minecraft') {
              const minecraftColors = {
                'LIGHT': 'bg-gradient-to-br from-yellow-200 via-amber-300 to-orange-400',
                'DARK': 'bg-gradient-to-br from-gray-700 via-slate-800 to-zinc-900',
                'WATER': 'bg-gradient-to-br from-blue-200 via-cyan-300 to-teal-400',
                'FIRE': 'bg-gradient-to-br from-orange-300 via-red-400 to-pink-500',
                'EARTH': 'bg-gradient-to-br from-green-300 via-emerald-400 to-teal-500',
                'WIND': 'bg-gradient-to-br from-sky-200 via-blue-300 to-indigo-400',
                'DIVINE': 'bg-gradient-to-br from-violet-200 via-purple-300 to-indigo-400'
              };
              return minecraftColors[cardData.attribute] || minecraftColors['EARTH'];
            }
            
            if (cardData.type === 'spell') {
              const spellColors = {
                'Normal': 'bg-gradient-to-br from-green-200 via-emerald-300 to-teal-400',
                'Quick-Play': 'bg-gradient-to-br from-lime-200 via-green-300 to-emerald-400',
                'Continuous': 'bg-gradient-to-br from-teal-200 via-cyan-300 to-blue-400',
                'Equip': 'bg-gradient-to-br from-yellow-200 via-green-300 to-teal-400',
                'Field': 'bg-gradient-to-br from-emerald-200 via-green-300 to-lime-400',
                'Ritual': 'bg-gradient-to-br from-indigo-200 via-green-300 to-emerald-400'
              };
              return spellColors[cardData.spellType] || spellColors['Normal'];
            }
            
            if (cardData.type === 'trap') {
              const trapColors = {
                'Normal': 'bg-gradient-to-br from-pink-200 via-rose-300 to-red-400',
                'Continuous': 'bg-gradient-to-br from-fuchsia-200 via-pink-300 to-rose-400',
                'Counter': 'bg-gradient-to-br from-violet-200 via-purple-300 to-pink-400'
              };
              return trapColors[cardData.trapType] || trapColors['Normal'];
            }
            
            return 'bg-gradient-to-br from-gray-200 via-slate-300 to-zinc-400';
          };

          // Dynamic border colors
          const getCardBorder = () => {
            if (cardData.type === 'monster') {
              const monsterBorders = {
                'LIGHT': 'border-amber-600',
                'DARK': 'border-purple-800',
                'WATER': 'border-blue-600',
                'FIRE': 'border-red-600',
                'EARTH': 'border-yellow-600',
                'WIND': 'border-teal-600',
                'DIVINE': 'border-orange-600'
              };
              return monsterBorders[cardData.attribute] || monsterBorders['LIGHT'];
            }
            
            if (cardData.type === 'minecraft') {
              const minecraftBorders = {
                'LIGHT': 'border-yellow-600',
                'DARK': 'border-gray-800',
                'WATER': 'border-cyan-600',
                'FIRE': 'border-red-600',
                'EARTH': 'border-emerald-600',
                'WIND': 'border-blue-600',
                'DIVINE': 'border-purple-600'
              };
              return minecraftBorders[cardData.attribute] || minecraftBorders['EARTH'];
            }
            
            if (cardData.type === 'spell') {
              const spellBorders = {
                'Normal': 'border-green-600',
                'Quick-Play': 'border-lime-600',
                'Continuous': 'border-cyan-600',
                'Equip': 'border-teal-600',
                'Field': 'border-emerald-600',
                'Ritual': 'border-indigo-600'
              };
              return spellBorders[cardData.spellType] || spellBorders['Normal'];
            }
            
            if (cardData.type === 'trap') {
              const trapBorders = {
                'Normal': 'border-pink-600',
                'Continuous': 'border-rose-600',
                'Counter': 'border-purple-600'
              };
              return trapBorders[cardData.trapType] || trapBorders['Normal'];
            }
            
            return 'border-gray-600';
          };

          const attributeSymbols = {
            LIGHT: '‚òÄÔ∏è',
            DARK: '‚ö´',
            WATER: 'üíß',
            FIRE: 'üî•',
            EARTH: 'üåç',
            WIND: 'üí®',
            DIVINE: '‚ú®'
          };

          const resetCard = () => {
            setCardData({
              name: 'Herobrine',
              type: 'minecraft',
              attribute: 'DARK',
              level: 10,
              monsterType: 'Creepypasta/Effect',
              minecraftType: 'Creepypasta',
              attack: 2500,
              defense: 2000,
              description: 'A mysterious entity that haunts Minecraft worlds. When summoned: All opponent monsters lose 500 ATK. If this card destroys a monster by battle, place 1 "Cursed Block" token on your field.',
              spellType: 'Normal',
              trapType: 'Normal'
            });
          };

          const generateRandomCard = () => {
            const names = ['Shadow Dragon', 'Lightning Warrior', 'Mystic Phoenix', 'Crystal Beast', 'Dark Magician Girl', 'Cyber Dragon', 'Elemental Hero', 'Blue-Eyes Ultimate'];
            const attributes = ['LIGHT', 'DARK', 'WATER', 'FIRE', 'EARTH', 'WIND'];
            const monsterTypes = ['Dragon/Effect', 'Warrior/Normal', 'Spellcaster/Effect', 'Beast/Normal', 'Machine/Effect', 'Fiend/Effect'];
            const descriptions = [
              'A powerful creature that commands the elements.',
              'This warrior fights with honor and strength.',
              'A mystical being with incredible magical powers.',
              'Born from ancient magic, this creature is unstoppable.',
              'A legendary monster that brings hope to its summoner.'
            ];

            setCardData({
              ...cardData,
              name: names[Math.floor(Math.random() * names.length)],
              attribute: attributes[Math.floor(Math.random() * attributes.length)],
              level: Math.floor(Math.random() * 8) + 1,
              monsterType: monsterTypes[Math.floor(Math.random() * monsterTypes.length)],
              attack: Math.floor(Math.random() * 3500) + 500,
              defense: Math.floor(Math.random() * 3000) + 500,
              description: descriptions[Math.floor(Math.random() * descriptions.length)]
            });
          };

          const handleInputChange = (field, value) => {
            setCardData(prev => ({ ...prev, [field]: value }));
          };

          const handleImageUpload = (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => setCardImage(e.target.result);
              reader.readAsDataURL(file);
            }
          };

          const removeImage = () => {
            setCardImage(null);
          };

          const renderStars = (level) => {
            return '‚≠ê'.repeat(Math.min(level, 12));
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-blue-900 via-purple-900 to-indigo-900 p-4">
              <div className="max-w-7xl mx-auto">
                <h1 className="text-4xl font-bold text-center text-white mb-8 drop-shadow-lg">
                  üé¥ Yu-Gi-Oh! Card Creator
                </h1>
                
                <div className="flex flex-col lg:flex-row gap-8">
                  {/* Card Preview */}
                  <div className="flex-1 flex justify-center">
                    <div className={`w-80 h-112 ${getCardColors()} border-4 ${getCardBorder()} rounded-xl shadow-2xl p-4 font-serif relative overflow-hidden`}>
                      {/* Enhanced holographic foil effect with antique feel */}
                      <div className="absolute inset-0 bg-gradient-to-br from-transparent via-amber-100/20 to-transparent opacity-40 pointer-events-none"></div>
                      <div className="absolute inset-0 bg-gradient-to-tr from-transparent via-yellow-200/10 to-transparent opacity-30 pointer-events-none"></div>
                      
                      {/* Card Name */}
                      <div className="text-xl font-bold text-center mb-2 bg-gradient-to-r from-amber-50 to-yellow-100 rounded px-2 py-1 border-2 border-amber-400 relative z-10 shadow-inner">
                        {cardData.name}
                      </div>

                      {/* Card Image Area */}
                      <div className="w-full h-48 bg-gradient-to-br from-amber-100 via-yellow-200 to-orange-300 border-2 border-amber-600 rounded mb-3 flex items-center justify-center overflow-hidden relative shadow-inner">
                        {cardImage ? (
                          <img src={cardImage} alt="Card artwork" className="w-full h-full object-cover" />
                        ) : (
                          <div className="flex flex-col items-center justify-center text-amber-800">
                            <div className="text-6xl mb-2 drop-shadow-lg">{getSmartCardEmoji()}</div>
                          </div>
                        )}
                        {/* Enhanced image border frame effect */}
                        <div className="absolute inset-0 border-2 border-amber-500 rounded opacity-40 pointer-events-none shadow-inner"></div>
                        <div className="absolute inset-0 bg-gradient-to-br from-transparent via-yellow-200/20 to-transparent pointer-events-none"></div>
                      </div>

                      {/* Attribute and Level (for monsters) */}
                      {(cardData.type === 'monster' || cardData.type === 'minecraft') && (
                        <div className="flex justify-between items-center mb-2">
                          <div className="text-lg flex items-center gap-1">
                            {attributeSymbols[cardData.attribute]} {cardData.attribute}
                          </div>
                          <div className="text-sm">
                            {renderStars(cardData.level)}
                          </div>
                        </div>
                      )}

                      {/* Monster Type */}
                      {cardData.type === 'monster' && (
                        <div className="text-sm bg-gradient-to-r from-amber-100 to-yellow-200 rounded px-2 py-1 mb-2 border border-amber-400 shadow-sm">
                          [{cardData.monsterType}]
                        </div>
                      )}

                      {/* Minecraft Type */}
                      {cardData.type === 'minecraft' && (
                        <div className="text-sm bg-gradient-to-r from-green-200 to-emerald-300 rounded px-2 py-1 mb-2 border border-green-500 shadow-sm">
                          [{cardData.minecraftType}]
                        </div>
                      )}

                      {/* Spell Type */}
                      {cardData.type === 'spell' && (
                        <div className="text-sm bg-gradient-to-r from-green-200 to-teal-300 rounded px-2 py-1 mb-2 flex items-center border border-green-500 shadow-sm">
                          <span className="mr-2">ü™Ñ</span>
                          [Spell Card/{cardData.spellType}]
                        </div>
                      )}

                      {/* Trap Type */}
                      {cardData.type === 'trap' && (
                        <div className="text-sm bg-gradient-to-r from-pink-200 to-rose-300 rounded px-2 py-1 mb-2 flex items-center border border-pink-500 shadow-sm">
                          <span className="mr-2">ü™§</span>
                          [Trap Card/{cardData.trapType}]
                        </div>
                      )}

                      {/* Description */}
                      <div className="text-xs bg-gradient-to-br from-amber-50 via-yellow-100 to-orange-200 rounded p-2 mb-3 h-24 overflow-y-auto border-2 border-amber-400 leading-tight shadow-inner">
                        <div className="text-justify text-amber-900">
                          {cardData.description}
                        </div>
                      </div>

                      {/* ATK/DEF (for monsters) */}
                      {(cardData.type === 'monster' || cardData.type === 'minecraft') && (
                        <div className="flex justify-between bg-gradient-to-r from-amber-200 via-yellow-300 to-orange-400 rounded px-2 py-1 text-sm font-bold border-2 border-amber-500 shadow-inner">
                          <span className="text-red-700">ATK/{cardData.attack}</span>
                          <span className="text-blue-700">DEF/{cardData.defense}</span>
                        </div>
                      )}

                      {/* Card ID/Set number */}
                      <div className="absolute bottom-1 right-2 text-xs text-gray-600 font-mono">
                        {cardData.type === 'minecraft' ? 'MC-001' : 'YGO-001'}
                      </div>
                    </div>
                  </div>

                  {/* Controls */}
                  <div className="flex-1 max-w-md mx-auto lg:mx-0">
                    <div className="bg-white rounded-xl shadow-2xl p-6">
                      <h2 className="text-2xl font-bold mb-6 text-gray-800">Card Editor</h2>
                      
                      <div className="space-y-4">
                        {/* Quick Actions */}
                        <div className="flex gap-2">
                          <button
                            onClick={generateRandomCard}
                            className="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                          >
                            üé≤ Random Card
                          </button>
                          <button
                            onClick={resetCard}
                            className="flex-1 bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition-colors"
                          >
                            üîÑ Reset
                          </button>
                        </div>

                        {/* Card Name */}
                        <div>
                          <label className="block text-sm font-medium mb-1">Card Name</label>
                          <input
                            type="text"
                            value={cardData.name}
                            onChange={(e) => handleInputChange('name', e.target.value)}
                            className="w-full border rounded-lg px-3 py-2"
                          />
                        </div>

                        {/* Card Type */}
                        <div>
                          <label className="block text-sm font-medium mb-1">Card Type</label>
                          <select
                            value={cardData.type}
                            onChange={(e) => handleInputChange('type', e.target.value)}
                            className="w-full border rounded-lg px-3 py-2"
                          >
                            <option value="monster">Monster</option>
                            <option value="spell">Spell</option>
                            <option value="trap">Trap</option>
                            <option value="minecraft">Minecraft</option>
                          </select>
                        </div>

                        {/* Image Upload */}
                        <div>
                          <label className="block text-sm font-medium mb-1">Card Image</label>
                          <div className="space-y-2">
                            <input
                              type="file"
                              accept="image/*"
                              onChange={handleImageUpload}
                              className="w-full border rounded-lg px-3 py-2 text-sm"
                            />
                            {cardImage && (
                              <div className="space-y-2">
                                <div className="text-sm text-gray-600">Preview:</div>
                                <img 
                                  src={cardImage} 
                                  alt="Current card image" 
                                  className="w-32 h-32 object-cover border rounded-lg"
                                />
                                <button
                                  onClick={removeImage}
                                  className="text-red-500 hover:text-red-700 text-sm underline"
                                >
                                  Remove image
                                </button>
                              </div>
                            )}
                            {!cardImage && cardData.name === 'Herobrine' && (
                              <div className="text-sm text-gray-500 italic">
                                Auto-generated Herobrine image will appear when name is "Herobrine"
                              </div>
                            )}
                            {!cardImage && cardData.name !== 'Herobrine' && (
                              <div className="text-sm text-gray-500 italic">
                                {getSmartCardEmoji()} Auto-detected from "{cardData.name}"
                              </div>
                            )}
                          </div>
                        </div>

                        {/* Monster/Minecraft specific fields */}
                        {(cardData.type === 'monster' || cardData.type === 'minecraft') && (
                          <>
                            {/* Attribute */}
                            <div>
                              <label className="block text-sm font-medium mb-1">Attribute</label>
                              <select
                                value={cardData.attribute}
                                onChange={(e) => handleInputChange('attribute', e.target.value)}
                                className="w-full border rounded-lg px-3 py-2"
                              >
                                <option value="LIGHT">LIGHT ‚òÄÔ∏è</option>
                                <option value="DARK">DARK ‚ö´</option>
                                <option value="WATER">WATER üíß</option>
                                <option value="FIRE">FIRE üî•</option>
                                <option value="EARTH">EARTH üåç</option>
                                <option value="WIND">WIND üí®</option>
                                <option value="DIVINE">DIVINE ‚ú®</option>
                              </select>
                            </div>

                            {/* Level */}
                            <div>
                              <label className="block text-sm font-medium mb-1">Level</label>
                              <input
                                type="number"
                                min="1"
                                max="12"
                                value={cardData.level}
                                onChange={(e) => handleInputChange('level', parseInt(e.target.value))}
                                className="w-full border rounded-lg px-3 py-2"
                              />
                            </div>

                            {/* Monster Type */}
                            {cardData.type === 'monster' && (
                              <div>
                                <label className="block text-sm font-medium mb-1">Monster Type</label>
                                <input
                                  type="text"
                                  value={cardData.monsterType}
                                  onChange={(e) => handleInputChange('monsterType', e.target.value)}
                                  className="w-full border rounded-lg px-3 py-2"
                                  placeholder="e.g., Dragon/Effect"
                                />
                              </div>
                            )}

                            {/* Minecraft Type */}
                            {cardData.type === 'minecraft' && (
                              <div>
                                <label className="block text-sm font-medium mb-1">Minecraft Type</label>
                                <input
                                  type="text"
                                  value={cardData.minecraftType}
                                  onChange={(e) => handleInputChange('minecraftType', e.target.value)}
                                  className="w-full border rounded-lg px-3 py-2"
                                  placeholder="e.g., Mob/Boss"
                                />
                              </div>
                            )}

                            {/* ATK/DEF */}
                            <div className="flex gap-2">
                              <div className="flex-1">
                                <label className="block text-sm font-medium mb-1">ATK</label>
                                <input
                                  type="number"
                                  min="0"
                                  max="9999"
                                  value={cardData.attack}
                                  onChange={(e) => handleInputChange('attack', parseInt(e.target.value))}
                                  className="w-full border rounded-lg px-3 py-2"
                                />
                              </div>
                              <div className="flex-1">
                                <label className="block text-sm font-medium mb-1">DEF</label>
                                <input
                                  type="number"
                                  min="0"
                                  max="9999"
                                  value={cardData.defense}
                                  onChange={(e) => handleInputChange('defense', parseInt(e.target.value))}
                                  className="w-full border rounded-lg px-3 py-2"
                                />
                              </div>
                            </div>
                          </>
                        )}

                        {/* Spell Type */}
                        {cardData.type === 'spell' && (
                          <div>
                            <label className="block text-sm font-medium mb-1">Spell Type</label>
                            <select
                              value={cardData.spellType}
                              onChange={(e) => handleInputChange('spellType', e.target.value)}
                              className="w-full border rounded-lg px-3 py-2"
                            >
                              <option value="Normal">Normal</option>
                              <option value="Quick-Play">Quick-Play</option>
                              <option value="Continuous">Continuous</option>
                              <option value="Equip">Equip</option>
                              <option value="Field">Field</option>
                              <option value="Ritual">Ritual</option>
                            </select>
                          </div>
                        )}

                        {/* Trap Type */}
                        {cardData.type === 'trap' && (
                          <div>
                            <label className="block text-sm font-medium mb-1">Trap Type</label>
                            <select
                              value={cardData.trapType}
                              onChange={(e) => handleInputChange('trapType', e.target.value)}
                              className="w-full border rounded-lg px-3 py-2"
                            >
                              <option value="Normal">Normal</option>
                              <option value="Continuous">Continuous</option>
                              <option value="Counter">Counter</option>
                            </select>
                          </div>
                        )}

                        {/* Description */}
                        <div>
                          <label className="block text-sm font-medium mb-1">Description</label>
                          <textarea
                            value={cardData.description}
                            onChange={(e) => handleInputChange('description', e.target.value)}
                            className="w-full border rounded-lg px-3 py-2 h-24 resize-none"
                            placeholder="Enter card effect or description..."
                          />
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<YuGiOhCardCreator />, document.getElementById('root'));
    </script>
</body>
</html>
